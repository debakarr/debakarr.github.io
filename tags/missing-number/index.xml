<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Missing Number - Tag - Debakar Roy</title>
        <link>http://debakarr.github.io/tags/missing-number/</link>
        <description>Missing Number - Tag - Debakar Roy</description>
        <generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 17 Jun 2019 00:00:00 &#43;0000</lastBuildDate><atom:link href="http://debakarr.github.io/tags/missing-number/" rel="self" type="application/rss+xml" /><item>
    <title>[LeetCode] 268. Missing Number</title>
    <link>http://debakarr.github.io/posts/missing-number/</link>
    <pubDate>Mon, 17 Jun 2019 00:00:00 &#43;0000</pubDate>
    <author>Debakar Roy</author>
    <guid>http://debakarr.github.io/posts/missing-number/</guid>
    <description><![CDATA[Missing Number Link to original Problem on LeetCode
Given an array containing n distinct numbers taken from 0, 1, 2, &hellip;, n, find the one that is missing from the array.
Example 1:
Input: [3,0,1] Output: 2
Example 2:
Input: [9,6,4,2,3,5,7,0,1] Output: 8
Note:
Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?
Company: Amazon, Google
Solution 1 (Using XOR):
class Solution(object): def missingNumber(self, nums): &#34;&#34;&#34; :type nums: List[int] :rtype: int &#34;&#34;&#34; # We know XOR of same number is 0 # We also know that len(nums) is present in the list # iff it is not the number which is absent # So we keep len(nums) in result result = len(nums) # Then we loop through each number # and XOR the result with index and number for i, num in enumerate(nums): result ^= i result ^= num # By the end the absent number will be present in result return result Solution 2 (Using Sum):]]></description>
</item>
</channel>
</rss>
